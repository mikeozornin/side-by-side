Я хочу сделать веб-приложение для быстрого тестирования дизайн-макетов. Называется side-by-side.

# Сценарий дизайнера
1. Загрузить в side-by-side два макета
2. Получить ссылку на голосование
3. Отправить ссылку в чат команды
4. Люди из чата заходят на страницу и видят две картинки. Отдают голос за одну из них.
5. После окончания голосования (24 часа) голосовать нельзя и показываются результаты.

# Технический стек
— В качестве сервера будем использовать приложение на bun.
— В качестве базы данных будем использовать sqlite или PostgreSQL. В ней будем хранить все, кроме самих файлов. Файлы будем хранить на файловой системе.
Структура папок для данных:
* data/ — папка для аттачей
* data/{voting_id} — папка для аттачей конкретного голосования, там будут лежать два файла разных вариантов
* Приложение должно работать на ubuntu
* UI-компоненты: shadcn/ui, lucide-react, а также сторонние компоненты, которые https://www.shadcn.io/components/forms/dropzone.
* Серверные компоненты максимально стандартные, входящие в bun, только при необходимости добавляем свои.

# Интерфейс
1. Главная: список голосований
* Превьюшка голосования: две картинки через косую черту
* Название
* Оставшееся время
Сверху показываются те, где человек не голосовал, дальше после заголовка те, где он голосовал

2. Голосование:
Название
Картинка1 и картинка2 показываются слева-справа, клик по картинке — выбор. Выбранная картинка показывается с большой иконкой галочка, а невыбранная становится бледной и черно-белой.
Внизу появляется кнопка подтверждения.
После голосования открывается главная страница.

3. Создание
Название — сюда дизайнер пишет вопрос
Два поля file upload для двух картинок
После создания редирект на созданное голосование

# Прочие особенности
* Перед сохранением файлов на диск файлы нужно прогнать через оптимизаторы, чтобы сэкономить место на диске. Можно использовать установленные в ОС бинарные программы. 
* Доступ пока будет без логина. После публикации вариантов отредактировать их нельзя, даже автору.
* Защита от накруток:
  * IndexedDB браузера хранит список проголосованных дизайнов
  * Один голос на дизайн в рамках одного браузера
  * Если обходят через другой браузер - принимаем как ограничение
* Роутинг hashrouting, по сути приложение SPA
* Десктопная версия, мобильная пока не требуется

# Вопросы и ответы (Q&A, уточнения спецификации)

## Роли и доступ
- Роли: Автор и голосующие. Других ролей не планируется.
- Ссылка на голосование: публичная, идентификатор — UUID (короткие slug не требуются).
- Доступ без логина. После публикации редактирование и удаление голосования не предусмотрены.

## Маршруты SPA и навигация
- Маршруты: `/#/` (список), `/#/new` (создание), `/#/v/:id` (голосование/итоги).
- После создания — редирект на страницу созданного голосования `/#/v/:id`.
- После голосования — обновляем страницу голосования `/#/v/:id` и фиксируем выбор (повторная отправка на клиенте недоступна).

## Главная страница (список)
- Сортировка: один общий список от старых к новым по времени создания. Завершённые естественно окажутся позже.
- Признак «я голосовал» — только визуально (серый/ч/б стиль для проголосованных). Фильтра и пагинации нет.
- «Оставшееся время» не показываем.

## Страница голосования (UX и правила показа)
- Две картинки отображаются слева-справа; клик по изображению — выбор. До подтверждения выбор можно менять. Перезагрузка до подтверждения — сброс выбора.
- Кнопка «Подтвердить» активна только при наличии выбора; после нажатия — дизейбл до ответа сервера, затем остаёмся на `/#/v/:id`.
- До окончания 24 часов результаты не показываются. Сразу после окончания отображаются проценты и победитель(и).
- Округление процентов: добиваем до суммы 100% (последний вариант корректируется).
- Ничья: оба считаются победителями.
- Если к моменту окончания 0 голосов — оба считаются проигравшими, показываем «Нет голосов», победителя нет.
- Отображение изображений: EXIF-ориентацию не учитываем; страница скроллится; области изображений занимают всю видимую область (100% вьюпорта) по высоте для обеих картинок, допускается вертикальный скролл.

## Антинакрутка (клиент)
- IndexedDB хранит факт голосования по `votingId` с временем и выбором: `voted:{votingId} -> { choice: 0|1, at: ISO }`.
- Клиент не позволяет отправить повторно, если запись есть в IndexedDB.
- Сервер принимает повторные голоса до окончания, но клиент их не отправит; после окончания сервер отклоняет по дате.

## Бэкенд, время и ограничения
- Bun 1.2 (ESM). Все времена в UTC; клиент отображает в локальной таймзоне.
- Завершение голосования вычисляется как `end_at = created_at + 24h` (UTC). Поле статуса в БД не храним.
- Лимит загрузки: до 10 МБ на файл. При превышении — человекочитаемая ошибка и повторный выбор файла.
- Сервер запрещает голосование после наступления `end_at` (включая ручные запросы).

## API (подтверждено)
- POST `/api/votings` — создать голосование
- GET `/api/votings` — список голосований
- GET `/api/votings/:id` — детали (включая `end_at`)
- POST `/api/votings/:id/vote` — голос
- GET `/api/votings/:id/results` — итоги

## Файлы и оптимизация
- **Поддерживаемые форматы изображений**: JPEG/PNG/WebP/AVIF/HEIC/HEIF
- **Поддерживаемые форматы видео**: MP4/WebM/MOV/AVI
- **Проверка файлов**: Проверяем расширение и заголовок `Content-Type`, а также реальный MIME тип по содержимому файла
- **HEIC/HEIF конвертация**: Автоматическая конвертация в JPG с качеством 90% для совместимости с браузерами
- **Путь к данным**: Задаётся через ENV `DATA_DIR`. Структура: `data/{voting_id}/` с файлами вариантов
- **Именование файлов**: `sha256` исходного содержимого + финальное расширение (напр. `a1b2...c9.jpg`)
- **Хранение**: Одна версия файла - оптимизированная (если успешно) или исходная (если оптимизация не удалась)
- **Утилиты оптимизации (Ubuntu)**: 
  - JPEG: jpegoptim (качество 85%)
  - PNG: pngquant (качество 65-80%)
  - WebP: cwebp (качество 80%)
  - AVIF: avifenc (качество 0-63, скорость 4)
  - HEIC/HEIF: Sharp (конвертация в JPG)
- **Метаданные**: EXIF/метаданные не срезаем, ресайз/нормализация формата не выполняются
- **Загрузка**: Два отдельных поля для файлов; поддержка вставки из буфера обмена

## База данных и индексы
- **Поддерживаемые СУБД**: SQLite (по умолчанию) и PostgreSQL
- **Выбор СУБД**: Через переменную окружения `DB_PROVIDER` ("sqlite" или "postgres")
- **Схема**:
  - `users(id, email, created_at)` — пользователи
  - `votings(id, title, created_at, end_at, duration_hours, is_public, user_id)` — голосования
  - `voting_options(id, voting_id, file_path, sort_order, pixel_ratio, width, height, media_type)` — варианты голосований
  - `votes(id, voting_id, option_id, user_id, created_at)` — голоса
  - `magic_tokens(token_hash, user_email, expires_at, used_at)` — токены magic link
  - `sessions(id, user_id, refresh_token_hash, expires_at, created_at)` — сессии
  - `figma_auth_codes(code_hash, user_id, expires_at, used_at)` — коды для Figma
- **Индексы**: По `created_at`, `end_at`, `user_id`, внешние ключи для связности
- **Миграции**: Автоматическое применение при запуске сервера

## Конфигурация и логи
- **Основные ENV**: `DATA_DIR`, `LOG_DIR`, `DB_PATH`, `PORT`, `BASE_URL`, `NODE_ENV`, `BUN_ENV`
- **Выбор СУБД**: `DB_PROVIDER` ("sqlite" или "postgres"), `DATABASE_URL` (для PostgreSQL)
- **Значения по умолчанию**: 
  - `DATA_DIR=/var/app/side-by-side/data`
  - `LOG_DIR=/var/app/side-by-side/logs` 
  - `PORT=3000`
  - `DB_PATH=/var/app/side-by-side/app.db` (SQLite)
- **PostgreSQL**: Требует `DATABASE_URL` в формате `postgresql://user:password@host:port/database`
- **Логи**: Текстовый файл `LOG_DIR/server.log`, ротация через внешние средства (logrotate)

## Деплой и раздача
- Целевая среда: Ubuntu LTS + Nginx. CORS не нужен (same-origin).
- Nginx раздаёт фронтенд-статику и папку `data/` напрямую, проксирует `/api/*` на bun.
- Кэширование/ETag для изображений и фронтенд-бандла настраивается на стороне Nginx (Vite выдаёт хэшированные имена файлов).

## Тестирование
- **Серверные тесты**: Bun Test с покрытием 53 тестами
  - Тестирование API эндпоинтов (auth, votings)
  - Тестирование утилит аутентификации
  - Тестирование запросов к базе данных
  - In-memory SQLite для изоляции тестов
- **Клиентские тесты**: Vitest + React Testing Library
  - Тестирование React компонентов
  - Тестирование контекстов и хуков
  - Тестирование утилит медиафайлов
  - jsdom для симуляции DOM
- **Покрытие**: >80% для критических путей сервера, >70% для компонентов клиента
- **Запуск тестов**: 
  - Сервер: `cd server && bun test`
  - Клиент: `cd client && npm test`

## Прочее
- Локализуемость заложить; стартовая локаль — русская.
- Open Graph теги не требуются. Rate limit не включаем (кроме базовой защиты от спама для создания голосований и magic links).

## Система авторизации

### Роли и доступ
- **Авторы** (требуют авторизации): создание и удаление голосований
- **Голосующие** (анонимные): участие в голосованиях без регистрации
- **Figma плагин**: авторизация через код с веб-страницы

### Аутентификация
- **Magic Link** (веб): email → письмо со ссылкой → автоматическая авторизация
- **Pairing Code** (Figma): веб-страница генерирует код → ввод в плагин → авторизация
- **Сессии**: JWT access token (15 мин) + refresh token (30 дней, HttpOnly cookie)
- **Dev режим**: автоматическая авторизация без отправки email при `NODE_ENV=development`

### Режимы доступа (анонимный / magic-links)
- `AUTH_MODE=anonymous` (анонимный доступ):
  - Голосующие не обязаны логиниться, UI не требует входа.
  - `POST /api/votings/:id/vote` допускается без `Authorization`.
  - В БД голоса пишутся с `votes.user_id = NULL`.
  - Защита от повторного голосования — на клиенте: запись `localStorage`/IndexedDB `voted_{votingId}` с выбранным вариантом и временем.
  - Сервер не рассчитывает признак «голосовал» per-user; `GET /api/votings/:id` не возвращает `hasVoted/selectedOption` для анонимов.

- `AUTH_MODE=magic-links` (доступ с авторизацией):
  - Для голосования требуется вход (magic link). Клиент добавляет `Authorization: Bearer <accessToken>`.
  - Сервер запрещает повторное голосование по `votes.user_id` (один голос на пользователя).
  - `GET /api/votings/:id` возвращает `hasVoted: boolean` и `selectedOption: number|null` для авторизованного пользователя.
  - Клиент при попытке повторного голосования показывает модальное окно «Вы уже голосовали» (без эффекта «голос учтён сейчас»), блокирует кнопку и подсвечивает выбранный вариант.

- Dev-упрощение: `AUTO_APPROVE_SESSIONS=true` — авто-логин без письма; `refreshToken` хранится в HttpOnly cookie, `accessToken` — в `localStorage` для восстановления после перезагрузки.

### API эндпоинты авторизации
- `POST /api/auth/magic-link` — запрос magic link
- `POST /api/auth/verify-token` — верификация magic link
- `POST /api/auth/refresh` — обновление access token
- `POST /api/auth/logout` — выход из системы
- `GET /api/auth/figma-code` — генерация кода для Figma (без rate limiting, один активный код на пользователя)
- `POST /api/auth/figma-verify` — верификация кода Figma

### Защищенные эндпоинты
- `POST /api/votings` — создание голосования (требует авторизации)
- `DELETE /api/votings/:id` — удаление голосования (только автор)

### База данных (дополнительные таблицы)
- `users(id, email, created_at)` — пользователи
- `sessions(id, user_id, refresh_token_hash, expires_at, created_at)` — сессии
- `magic_tokens(token_hash, email, expires_at, created_at)` — токены magic link
- `figma_auth_codes(code_hash, user_id, expires_at, created_at)` — коды для Figma
- `votings.user_id` — связь голосования с автором

### Безопасность
- Refresh token ротация при каждом обновлении
- Хеширование токенов в БД (bcrypt)
- HttpOnly cookies для refresh token
- Валидация Figma плагина через заголовок `X-Figma-Plugin`
- Защита от CSRF через SameSite cookies
- Figma коды: при генерации нового кода удаляются все предыдущие коды пользователя (один активный код одновременно)